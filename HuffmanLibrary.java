import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class HuffmanLibrary {
  
  //For running purposes
  public static void main (String[] args) {
    
    if (args.length == 2) {
      huffman_coder(args[0], args[1]);
    }
    else {
      System.out.print("Input and output filenames required, in that order, as arguments.");
    }
  }
  
  //Simply returns the file contents as a string
  public static String readFileAsString(String filename) {
    
    try {
      FileReader fr = new FileReader(filename);
      StringBuilder sb = new StringBuilder();
      //negative one is already used, for when the reader runs out of file to read, 
      //but it needs to be initialized to something and zero is a valid cahracter.
      int character = -2;
      while (character != -1) {
      
        character = fr.read();
        //if statement blocks the -1 that happens at the end of the file
        if (character >= 0)
          sb.append((char) character);
      }
      return sb.toString();
    }
    //can trigger on the Filereader constructor
    catch (FileNotFoundException e) {
      System.out.print("File not found or unreadable.");
      return "";
    }
    //can trigger on the read() method
    catch (IOException e) {
      System.out.println("I/O Error");
      return "";
    }
  }
  
  //creates the linked list from the String produced by the previous method
  public static HLinkedList createHList(String fileContents) {
    
    //these lines initialize variables and handle the first character of the file (needed to construct the linked list)
    //No provision is made to handle a file with no data because compressing such a file is pointless
    int index = 0;
    char character = fileContents.charAt(index);
    HLinkedList hll = new HLinkedList(new HTreeNode(character, null));
    index += 1;
    int position = 2;
    
    //the rest of the characters are handled here
    while (index < fileContents.length()) {
      
      character = fileContents.charAt(index);
      HTreeNode node = hll.find(character);
      //if the character is not already represented in the list
      if (node == null) {
        hll.insertIntoPosition(new HTreeNode(character, null), position);
        position += 1;
      }
      //if the character is represented in the list
      else {
        node.incrementFrequency();
      }
      index += 1;
    }
    return hll;
  }
  
  //sorts the linked list generated by the above method by frequency. Lowest frequency is found at the head.
  public static HLinkedList getSortedLinkedList(HLinkedList unsorted) {
    HTreeNode unsortedRunner = unsorted.getHeadNode();
    HLinkedList sorted = new HLinkedList(null);
    
    HTreeNode sortedRunner;
    while (unsortedRunner != null) {
      //run through the unsorted list 
      
      sortedRunner = sorted.getHeadNode();
      
      //the first addition to sorted
      if (sortedRunner == null) {
        sorted.insertIntoPosition(unsortedRunner, 1);
      }
      //addition to a sorted with one node
      else if (sortedRunner.getNext() == null) {
        if (sortedRunner.getFrequency() <= unsortedRunner.getFrequency()) {
          sorted.insertIntoPosition(unsortedRunner, 2);
        }
        else {
          sorted.insertIntoPosition(unsortedRunner, 1);
        }
      }
      //additions to a reasonably populated sorted
      else {
        int position = 1;
        //run through sorted until the node to be inserted has a higher frequency than all nodes before it
        while (sortedRunner != null && sortedRunner.getFrequency() > unsortedRunner.getFrequency()) {
          sortedRunner = sortedRunner.getNext();
          position += 1;
        }
        sorted.insertIntoPosition(unsortedRunner, position);
      }
      //increment to the next node to be inserted
      unsortedRunner = unsortedRunner.getNext();
    }
    return sorted;
  }
  
  //Creates the HTree from the sorted linked list produced in the above method
  public static HTree createHuffmanTree(HLinkedList data) {
    
    //A queue to hold the nodes from the linked list (leaves)
    HNodeQueue leafQueue = new HNodeQueue();
    //A queue to hold the nodes produced below (not leaves)
    HNodeQueue compositeQueue = new HNodeQueue();
    
    //Loop adds each node from the ordered linked list to the leaf queue
    //the first node off the queue will have lowest priority
    HTreeNode listrunner = data.getHeadNode();
    while (listrunner != null) {
      leafQueue.add(listrunner);
      listrunner = listrunner.getNext();
    }
    
    //comparator variables
    HTreeNode nodeFirst = null;
    HTreeNode nodeSecond = null;
    
    //loop keeps going until only one node is left in both queues, as that final node is the root of the tree
    while (leafQueue.getLength() + compositeQueue.getLength() > 1) {
      //if there is nothing in the leaf queue, program takes two from composite
      if (leafQueue.getLength() == 0) {
        nodeFirst = compositeQueue.look();
        compositeQueue.remove();
        nodeSecond = compositeQueue.look();
        compositeQueue.remove();
        compositeQueue.add(new HTreeNode(nodeFirst.getFrequency() + nodeSecond.getFrequency(),
                                         nodeFirst, nodeSecond));
      }
      //if there is nothing in the composite queue, program must take two from leaf
      else if (compositeQueue.getLength() == 0) {
        nodeFirst = leafQueue.look();
        leafQueue.remove();
        nodeSecond = leafQueue.look();
        leafQueue.remove();
        compositeQueue.add(new HTreeNode(nodeFirst.getFrequency() + nodeSecond.getFrequency(), 
                                         nodeFirst, nodeSecond));
      }
      //if both queues have a population, program takes the lower (in frequency)
      else {
        int leafFrequency = leafQueue.look().getFrequency();
        int compositeFrequency = compositeQueue.look().getFrequency();
        if (leafFrequency <= compositeFrequency) {
          //pull the one off leaf queue and assign it to nodeFirst, then repeat the comparison to get nodeSecond
          nodeFirst = leafQueue.look();
          leafQueue.remove();
          //else statement handles leafQueue running out of elements in the middle of this step
          if (leafQueue.getLength() > 0) {
            leafFrequency = leafQueue.look().getFrequency();
            compositeFrequency = compositeQueue.look().getFrequency();
            if (leafFrequency <= compositeFrequency) {
              //pull a node off the leaf queue for nodeSecond
              nodeSecond = leafQueue.look();
              leafQueue.remove();
            }
            else {
              //pull a node off the composite queue for NodeSecond
              nodeSecond = compositeQueue.look();
              compositeQueue.remove();
            }
          }
          else {
            //with no nodes in leaf, the next must come from composite
            nodeSecond = compositeQueue.look();
            compositeQueue.remove();
          }
        }
        else {
          //here nodeFirst comes off the composite queue
          nodeFirst = compositeQueue.look();
          compositeQueue.remove();
          //else statement handles compositeQueue running out of elements in the middle of this step
          if (compositeQueue.getLength() > 0) {
            leafFrequency = leafQueue.look().getFrequency();
            compositeFrequency = compositeQueue.look().getFrequency();
            if (leafFrequency <= compositeFrequency) {
              //pull a node off the leaf queue for nodeSecond
              nodeSecond = leafQueue.look();
              leafQueue.remove();
            }
            else {
              //pull a node off the composite queue for NodeSecond
              nodeSecond = compositeQueue.look();
              compositeQueue.remove();
            }
          }
          else {
            //with no nodes in composite, the next must come from leaf
            nodeSecond = leafQueue.look();
            leafQueue.remove();
          }
        }
        compositeQueue.add(new HTreeNode(nodeFirst.getFrequency() + nodeSecond.getFrequency(), 
                                         nodeFirst, nodeSecond));
      }
    }
    //the last node must be in the composite queue, and is the root of the final tree
    return new HTree(compositeQueue.look());
  }
  
  //assigns variable length bit codes to each character in the tree prodcued above, based on position therein
  public static void updateCodeValues(HTree tree) {
    
    //reference variables
    HTreeNode left = tree.getRoot().getLeft();
    HTreeNode right = tree.getRoot().getRight();
    
    if (left != null) {
      String codeLeft = new String();
      //each time the method recurses to the left, it appends a zero to the stringbuilder
      codeLeft = codeLeft + "0";
      updateCodeValuesRecursor(new HTree(left), codeLeft);
    }
    if (right != null) {
      String codeRight = new String();
      //right recurses cause the appending of a one
      codeRight = codeRight + "1";
      updateCodeValuesRecursor(new HTree(right), codeRight);
    }
  }
  
  //Helper method for updateCodeValues, allows the stringbuilders to transmit between recurses
  private static void updateCodeValuesRecursor(HTree tree, String code) {
    
    HTreeNode left = tree.getRoot().getLeft();
    HTreeNode right = tree.getRoot().getRight();
    
    if (left != null) {
      String codeLeft = new String(code);
      //each time the method recurses to the left, it appends a zero to the stringbuilder
      codeLeft = codeLeft + "0";
      updateCodeValuesRecursor(new HTree(left), codeLeft);
    }
    if (right != null) {
      String codeRight = new String(code);
      //right recurses cause the appending of a one
      codeRight = codeRight + "1";
      updateCodeValuesRecursor(new HTree(right), codeRight);
    }
    if (left == null && right == null) {
      //if the node is a root, then it the code constructed by the recursions is stored in the node's code field
      tree.getRoot().setCode(code);
    } 
  }
  
  //The overarch method
  public static void huffman_coder(String input_file, String output_file) {
    
    try {
      //intermediate stop as the length of the file is used below
      String fileContents = readFileAsString(input_file);
      //intermediate step since the list itself is referred to below
      HLinkedList list = getSortedLinkedList(createHList(fileContents));
      //finishes calling the above methods and assigns the codes to the nodes
      updateCodeValues(createHuffmanTree(list));
    
      int character = -2;
      int length = 1;
      FileReader fr = new FileReader(input_file);
      StringBuilder encoded = new StringBuilder();
      //loop reads each character from the input file, then writes the compressed bits to the output file
      int cieling = fileContents.length();
      while (length <= cieling) {
        character = fr.read();
        HTreeNode node = list.find((char) character);
        String code = node.getCode();
        
        encoded.append(code);
        length += 1;
      }
      BinaryFileWriter.createBinaryFile(encoded.toString(), output_file);
      
      /*Code was used to populate the TextFile_Encoding.txt file
      HTreeNode listrunner = list.getHeadNode();
      while (listrunner != null) {
        System.out.println(listrunner.getCharacter() + " - " + listrunner.getCode());
        listrunner = listrunner.getNext();
      }
      */
    }
    //can trigger on FileReader constructors
    catch (FileNotFoundException e) {
      System.out.print("File not found or unreadable.");
      return;
    }
    //can trigger on read() or write() methods, and on FileWriter constructors
    catch (IOException e) {
      System.out.print("I/O Exception");
      return;
    }
    //triggers in BinaryFileWriter
    catch (Exception e) {
      System.out.print("error in format");
      return;
    }
  }
}